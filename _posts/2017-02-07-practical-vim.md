---
layout: post
title: "Practical Vim 팁 요약 시리즈 - Register II"
description: "Vim 전문가는 어떻게 생각하는지를 팁 중심으로 설명하는 책 Practical Vim 2판을 요약하는 시리즈"
category: blog
tags: [practical, vim, tip, beginner, advance]
---

![Vim 3D](/images/posts/vim.jpg)

1. 목차
{:toc}

#### The System Clipboard ("+) and Selection ("*) Registers

지금까지 다룬 모든 레지스터는 Vim 내부에서 사용하는 레지스터이다. Vim에서 복사한 텍스트를 외부 프로그램에 붙여넣으려면(또는 그 반대) 시스템 클립보드를 사용해야 한다.

Vim의 플러스 레지스터는 시스템 클립보드를 참조하며 `+` 기호로 사용할 수 있다(:h quote+).

외부 애플리케이션에서 복사하거나 잘라낸 텍스트를 Vim에서 사용하려면 `"+p` 명령으로 붙여넣을 수 있다. (또는 입력 모드에서 `<Ctrl-r>+` 명령을 사용) 반대로 Vim의 복사 또는 삭제 명령 앞에 `"+`를 붙이면 그 텍스트를 시스템 클립 보드에 저장되어 다른 애플리케이션에서 쉽게 붙여넣을 수 있다.

X11 윈도우 시스템에는 원시(primary) 클립보드라고 하는 다른 종류의 클립 보드가 있다. 이 클립보드는 가장 최근에 선택한 내용을 저장하며 마우스 가운데 버튼을 (만약 있다면) 눌러 붙여넣을 수 있다. Vim에서는 인용별(quotestar) 레지스터가 이 원시 클립보드와 연결되어 있으며 `*` 기호로 참조할 수 있다(:h quotestar).

윈도와 맥 OS X에는 원시 클립보드가 없기 때문에 `"+`,`"*` 레지스터는 둘 다 시스템 클립보드를 참조한다.

#### The Expression Register ("=)

Vim의 레지스터는 단순히 텍스트 블록을 저장하는 보관함이라고 생각할 수 있지만, `=` 기호로 참조하는 표현식 레지스터는 예외이다(:h quote=). 표현식 레지스터를 사용하면 Vim은 명령행 모드로 전환되고 `=` 프롬프트에 보여준다. Vim 스크립트 표현식을 입력한 다음에 `<CR>`을 눌러 스크립트를 실행할 수 있다. 표현식이 문자열(또는 쉽게 문자열로 강제 변환될 수 있는 값)을 반환하면 Vim은 그 결과를 사용한다.

#### More Registers

제거하기 명령 또는 복사하기 명령을 사용해서 이름 레지스터, 무명 레지스터, 복사 레지스터의 내용을 명시적으로 설정할 수 있다. Vim은 암시적으로 값이 설정된 레지스터도 제공한다. 전체적으로 읽기전용 레지스터로 알려져 있다(:h quote.).

| Register | Contents                   |
|----------|----------------------------|
| "%       | Name of the current file   |
| "#       | Name of the alternate file |
| ".       | Last inserted text         |
| ":       | Last Ex command            |
| "/       | Last search pattern        |

기술적으론 `"/` 레지스터는 읽기 전용이 아니며, `:let` 명령을 사용하여 명시적으로 검색 패턴을 저장할 수 있다(:h quote/). 하지만 편의상 이 표에 포함한다.

### Tip 62. Replace a Visual Selection with a Register

비주얼 모드에서 붙여넣기 명령을 사용하는 경우에 독특한 특징이 있다.

비주얼 모드에서 `p` 명령을 사용하면 특정 레지스터에 있는 내용으로 _선택한 영역을 대체한다_(:h v_p). 이 기능을 Tip.60의 "악! 복사한 내용을 날렸다" 문제를 해결할 때 사용할 수 있다.

`copy_and_paste/collection.js`

```javascript
collection = getCollection();
process(somethingInTheWay, target);
```

`yiw`를 입력해서 collection 단어를 무명 레지스터에 복사한다. 이제 `jww`로 복사한 단어를 넣을 위치인 somethungIhTheWay로 커서를 이동한다. `ve` 명령으로 somethungIhTheWay을 선택한다.
`p`를 눌러 선택 영역을 무명 레지스터에 있는 내용으로 대체한다.

이 해결책은 내가 가장 선호하는 방법이다. 삭제 단계가 없으므로 무명 레지스터를 사용하여 yank 및 put 작업을 수행 할 수 있다. 대신 삭제 및 붙여넣는 작업을 선택 영역을 대체하는 하나의 단계로 결합한다.

이 기법의 부가적인 효과를 이해하는 것도 중요하다. `u`를 눌러서 마지막 변경을 취소해보자. 이제 `gv`를 눌러서 마지막 선택 영역을 다시 선택하고 `p`를 입력한다. 무슨 일이 일어났는가? 아무 일도 일어나지 않았다!

이 작업을 다시 실행할 때는 `"0p` 명령을 사용해서 복사 레지스터의 내용으로 선택 영역을 대체해야 한다. 처음 `p` 명령을 사용했을 때는 무명 레지스터에 원하는 텍스트가 있었다. 두 번째에는 `p` 명령으로 지워진 문자열이 무명 레지스터에 덮어 쓰인다.

이 기능이 얼마나 이상한지는 표준 잘라내기, 복사하기, 붙여넣기 모델의 API와 비교해보면 더 명확하다. 이 API는 `setClipboard()`와 `getClipboard()`라는 메소드가 있다. 잘라내기와 복사하기 동작은 둘 다 `setClipboard()`를 호출하고 붙여넣기 동작은 `getClipboard()`를 호출한다. 비주얼 모드에서 `p` 명령을 사용하면 두 메소드를 동시에 사용한다: 무명 레지스터의 내용을 _가져오고_, 무명 레지스터의 내용을 _설정한다_. 즉, 무명 레지스터에서 붙여넣을 내용을 가져온 다음, 제거한 내용을 다시 무명 레지스터에 입력한다.

이 기능은 문서의 선택 영역과 레지스터에 있는 텍스트가 _서로의 위치를 맞바꾼다고_ 생각할 수 있다. 이 특징이 하나의 기능일까, 아니면 버그일까? 각자의 판단에 맡긴다.

#### Swap Two Words

이 부분은 실제 쓸 일이 없다. 저자도 그냥 두 단어를 `c3w`로 전부 지우고 다시 쓰는 게 빠르다고 함.(놀부)

### Tip 63. Paste from a Register

_일반 모드에서 붙여넣기 명령은 어떤 텍스트를 붙여넣는가에 따라서 다르게 동작할 수 있다. 행 단위 또는 문자 단위인지에 따라 다른 전략을 채택하는 것이 도움이 될 수 있다._

`p` 명령은 커서 다음에 레지스터에 있는 텍스트를 붙여넣는다(:h p). 대문자 `P` 명령은 커서 앞에 붙여넣는다.

행 단위 복사나 삭제 동작(`dd`, `yy`, `dap` 등)은 행 단위 레지스터를 만들고, 문자 단위 복사나 삭제 동작(`x`, `diw`, `das` 등)은 문자 단위 레지스터를 만든다. 보통 `p` 명령의 출력 결과는 상당히 직관적으로 동작한다(:h linewise-register).

#### Pasting Character-wise Regions

`p`와 `P`를 사용해야 하는 상황을 직관적으로 판단하기가 쉽지 않다. 실제로 잘못 입력하는 경우가 많아 `puP` 또는 `Pup`를 실제 체득하고 있다.

문자 단위로 선택할 필요가 없다. 일반 모드 `p`와 `P` 명령보다는 입력 모드에서 `<Ctrl-r>{register}` 명령으로 붙여 넣는 것을 자주 이용한다. 이 기법을 사용하면 레지스터에 있는 텍스트를 항상 커서 앞에 붙여넣는다. 마치 입력 모드에서 계속 타자하는 것과 같은 느낌이다.

입력 모드에서 `<Ctrl-r>"`로 무명 레지스터의 내용을 넣을 수 있고, `<Ctrl-r>0`로 복사 레지스터의 내용을 넣을 수 있다.

![단어 복사하고 입력 모드에서 대체하기](/images/posts/Copy_word_and_replace_word_I_Mode.gif)

`ciw` 명령을 사용하면 부수적인 혜택도 있다. 이제부터 `.` 명령이 현재 단어를 "collection"으로 대체한다.

#### Pasting Line-Wise Regions

행 단위 레지스터를 붙여넣으면 `p`는 현재 행 아래에, `P`는 현재 행 위에 텍스트를 붙여넣는다. 단어 단위 동작에 비해서 더 직관적이다.
`gp`와 `gP` 명령도 기억해둘만 하다. `p`, `P` 명령처럼 현재 행의 위 또는 아래에 텍스트를 붙여넣지만, 커서가 붙여넣은 텍스트의 시작 대신 끝에 위치한다. `gP` 명령은 특히 여러 행을 복사할 때 유용하다.

![코드 블럭 복사하고 붙여넣기](/images/posts/Copy_code_block_Paste.gif)

복사한 텍스트를 템플릿처럼 사용해서 표의 셀 내용만 원하는 대로 변경할 수 있다.

### Tip 64. Interact with the System Clipboard

_Vim의 내장된 put 명령 외에도 가끔 시스템  붙여넣기(paste) 기능을 사용할 때가 있다. 그러나 이것을 사용하면 터미널에서 Vim을 실행할 때 예기치 않은 결과가 발생할 수 있다. 시스템 붙여넣기 명령을 사용하기 전에 'paste' 옵션을 활성 상태로 하면 이러한 문제를 피할 수 있다._

다음과 같이 vim을 터미널에서 구동해보자.

```shell
$ vim -u NONE -N
```

시스템 클립보드를 붙여넣을 때 문제가 발생하는 경우는 대부분 'autoindent' 설정이 활성 상태이기 때문이다. 이 현상을 관찰하기 위해 다음처럼 설정을 활성한다.

```vim
:set autoindent
```

이제 다음 코드를 시스템 클립보드로 복사한다.

`copy_and_paste/fizz.rb`

```ruby
[1,2,3,4,5,6,7,8,9,10].each do |n|
  if n%5==0
    puts "fizz"
  else
    puts n
  end
end
```

#### Locating the System Paste Command

시스템 붙여넣기 명령을 사용하려면 자신의 시스템에 맞는 단축키를 사용해야 한다. OS X는 시스템 붙여넣기를 `Cmd-v`로 실행할 수 있다. 터미널이나 MacVim에서 사용하면 시스템 클립보드의 내용을 삽입한다.

리눅스와 윈도에서는 그리 깔끔하지 않다. 시스템 붙여넣기의 표준 키는 보통 `Ctrl-v`이다. 일반 모드에서 비주얼-블록 모드로 전환하고, 입력 모드에서는 문자를 문자 그대로 추가하거나 숫자 코드로 입력한다.

Linux의 터미널 에뮬레이터 중에는 시스템 클립보드에서 붙여넣는 동작을 하도록 수정된 버전의 `Ctrl-v`를 지원하기도 한다. 그러나, 몰라도 걱정하지 말자. 이 팁의 마지막에 나오는 `"*` 레지스터를 사용하는 대안이 있다.

#### Using the System Paste Command in Insert Mode

입력 모드로 전환하고 시스템 붙여넣기 명령을 사용하면 이상한 결과가 나타난다. 들여쓰기가 잘못된다. 입력 모드에서 시스템 붙여넣기 명령을 사용하면, 각각의 문자를 손으로 직접 입력한 것처럼 처리된다. 'autoindent' 설정이 켜져 있으면 새 행을 시작할 때마다 이전 행과 동일한 계층의 들여쓰기로 열을 맞춘다. 그러나 클립보드에 있는 코드는 이미 들여쓰기가 있는 코드이기 때문에 자동 들여쓰기에 더해진다. 그래서 결과에서 매번 줄이 오른쪽으로 점점 더 쏠린다.

GVim은 클립 보드에서 텍스트를 붙여 넣을 때 구분할 수 있고 그에 따라 동작을 조정할 수 있지만 Vim이 터미널 내부에서 실행될 때이 정보는 사용할 수 없습니다.

GVim은 클립보드에서 텍스트을 붙여넣는 것을 식별하고 그에 따라 처리하지만, 터미널에서 실행되는 Vim은 이 정보를 사용할 수 없다. 'paste' 옵셔능로 Vim에게 시스템 붙여넣기를 사용한다고 수동으로 경고할 수 있다. 'paste' 옵션을 켜면 Vim은 모든 입력 단축키, 축약을 끄고, 'autoindent'을 포함한 붙여넣기 옵션들을 재설정한다.(:h 'paste'). 이것으로 놀라지 않고 안전하게 붙여넣을 수 있다.

시스템 붙여넣기 명령을 완료하면 'paste' 옵션을 다시 꺼야 한다. 일반 모드로 돌아와 Ex 명령 `:set paste!`를 실행해야 한다. 입력 모드에서 벗어나지 않고 이 옵션을 쉽게 전환하는 방법은 없을까?

'paste' 옵션이 활성 상태이면 입력 모드의 커스텀 단축키를 사용할 수 없다. 대신 'pastetoggle' 옵션에 키를 배정할 수 있다(:h 'pastetoggle').

```vim
:set pastetoggle=<f5>
```

명령행을 실행하면 `<f5>`으로 붙여넣기 옵션을 전환할 수 있다. 입력 모드와 일반 모드 모두에서 동작한다. 단축키가 유용하다고 생각하면 `vimrc`에 추가한다.

#### Avoid Toggling 'paste' by Putting from the Plus Register

시스템 클립보드가 통합된 Vim을 사용하고 있다면 'paste' 옵션을 사용하지 않을 수 있다. 일반 모드 `"+p` 명령은 시스템 클립보드를 반영하는 플러스 레지스터의 내용을 붙여넣는다. 이 명령은 클립보드에 있는 들여쓰기를 그대로 지키기 때문에 아무 문제없이 클립보드의 내용을 붙여넣을 수 있다. 'paste'와 'autoindent' 옵션을 고민할 필요가 없다.

### 시리즈 포스트를 한 장의 페이지로도 정리합니다.

* [Practical Vim 2판 정리 페이지](https://nolboo.kim/practical-vim/)


